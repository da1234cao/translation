原文地址：:point_right: [AFL -- perf_tips.txt](https://github.com/google/AFL/blob/master/docs/perf_tips.txt)

```sh
Tips for performance optimization
```

此文件提供了对缓慢或浪费的任务进行故障排除的技巧。一般使用手册请参阅自述文件。

## 1. 保持你的测试用例小

这可能是最重要的一步！ 大型测试用例不仅需要花费更多的时间和内存来由被测试的二进制文件解析，而且还使得fuzzing处理的效率大大降低。

为了说明这一点，假设您随机地一次翻转文件中的位。 假设如果您翻转＃47位，将会遇到一个安全漏洞； 翻转任何其他位只会导致文档无效。

现在，如果您的开始测试用例的长度为100个字节，那么您将有71％的机会在前1,000个exec中触发错误-不错！ 但是，如果测试用例的长度为1 kB，则我们将在同一时间范围内随机击中正确模式的可能性将降低至11％。 并且，如果它具有10 kB的非必需杂项，则赔率下降到1％。

最重要的是，在输入较大的情况下，二进制文件现在的运行速度可能比以前慢5到10倍-因此，模糊效率的总体下降可能很容易高达500倍左右。

**在实践中，这意味着您不应该直接使用假期照片来模糊测试图像解析器。 而是生成一张很小的16x16图片，并通过jpegtran或pngcrunch运行该图片以取得良好效果。 大多数其他类型的文档也是如此**。

../testcases/*中有很多小型的开始测试用例-试试看或提交新的！

**如果要以更大的第三方语料库开头，请首先在该数据集上运行afl-cmin并设置积极的超时时间**。

## 2. 使用一个简单的目标

考虑在模糊测试中使用更简单的目标二进制文件。 例如，对于图像格式，捆绑的实用程序（例如djpeg，readpng或gifhisto）比ImageMagick的转换工具要快（10-20倍）-所有这些都在执行大致相同的库级图像解析代码。

即使您没有针对特定目标的轻量级工具，也请记住，您始终可以使用另一个相关的库来生成语料库，然后稍后将其手动输入到耗费更多资源的程序中。

[<font color=blue>译者注：对于目标中使用的二进制文件，选择尽量小的，且可以达到需要的功能。测试一个程序的时候，能不能不一个大程序分开来测试，不同的阶段有不同的输出。类似于流水线的方式测试，加快测试速度。</font>]

## 3. 使用LLVM instrumentation

当对慢速目标进行模糊处理时，可以使用llvm_mode / README.llvm中介绍的基于LLVM的检测模式，将性能提高2倍。 请注意，此模式需要使用clang，不适用于GCC。

LLVM模式还提供了一种“持久”的进程内模糊测试模式，该模式对于某些类型的自包含库可以很好地工作，对于快速目标，可以将性能提高5-10倍； 以及“deferred fork server”模式，该模式可以为启动开销高的程序提供巨大的好处。 两种模式都要求您编辑模糊程序的源代码，但是更改通常仅在策略上仅放置一行或两行。

## 4. 对二进制文件进行分析和优化

检查是否有任何明显改善性能的参数或设置。 例如，可以使用以下命令调用IJG jpeg和libjpeg-turbo随附的djpeg实用程序：

```shell
-dct fast -nosmooth -onepass -dither none -scale 1/4
```

...这将加快速度。 解码图像的质量相应下降，但这可能不是您关心的问题。

在某些程序中，可以完全禁用输出，或者至少使用计算上便宜的输出格式。 例如，使用图像转码工具，转换为BMP文件比转换为PNG快得多。

对于某些悠闲的解析器，启用“严格”模式（即在出现首次错误后进行救助）可能会导致文件更小，运行时间加快而又不影响覆盖率； 例如，对于sqlite，您可能需要指定-bail。

如果程序仍然太慢，则可以**使用strace -tt或等效的分析工具来查看目标二进制文件是否在做任何愚蠢的事情**。有时，您可以通过指定/dev/null作为配置文件，或者禁用某些工作不需要的编译时功能来加快处理速度（尝试./configure --help）。 众所周知，消耗资源的事情之一是通过exec *（），popen（），system（）或等效调用来调用其他实用程序。 例如，当tar判定输入文件是压缩档案时，它可以调用外部解压缩工具。

一些程序还可能有意调用sleep（），usleep（）或nanosleep（）。  vim就是一个很好的例子。 其他程序可能会尝试fsync()等等。**有第三方库可让您轻松删除此类代码**， https://launchpad.net/libeatmydata

[<font color=blue>译者注：这个挺好</font>]

在由于不可避免的初始化开销而导致速度较慢的程序中，您可能想要尝试LLVM延迟的forkserver模式（请参见llvm_mode / README.llvm），如上所述，它可以使速度提高多达10倍。

最后但并非最不重要的一点是，如果您正在使用ASAN并且性能不可接受，请考虑暂时将其关闭，然后**稍后使用启用了ASAN的二进制文件手动检查生成的语料库**。[<font color=blue>译者注：这里相当于把检查内存的功能摘出来。如果检查的内容可以分类，每次运行检查不同的内容，并行运行检查？感觉有点得不偿失。那对于过于消耗时间的内容检查，是不是可以摘出来做？以什么合适的尺度来判读是不是适合摘出来做。</font>]

## 5. Instrument just what you need

**仅对您实际上想要立即进行压力测试的库进行一次Instrument。 让程序使用系统范围内的非Instrument库来实现您实际上不想模糊的任何功能**。 例如，在大多数情况下，仅仅因为您要测试依赖于bignum数学的加密应用程序并不对libgmp进行Instrument。

谨防奇怪的第三方库附带的与源代码捆绑在一起的程序（Spidermonkey是一个很好的例子）。 Check ./configure options to use non-instrumented system-wide copies instead.

## 6. Parallelize your fuzzers

该模糊器被设计为每个作业需要大约1个核心。 这意味着，在4核系统上，您可以轻松运行四个并行的模糊测试作业，而对性能的影响不大。 有关如何执行此操作的提示，请参见parallel_fuzzing.txt。

afl-gotcpu实用程序可以帮助您了解系统上是否还有空闲的CPU容量。  （它不会告诉您有关内存带宽，缓存未命中率或类似因素，但不太可能引起您的注意。）

## 7. 检查内存使用和超时检查

如果您增加了-m或-t限制，这个限制数值超出了实际需要，请考虑将其重新拨回。

对于名义上速度非常快但对于某些输入变得缓慢的程序，您也可以尝试设置-t值，该值比afl-fuzz自己敢使用的值更具惩罚性。 在快速闲置的机器上，降低到-t 5可能是一个可行的计划。

**-m参数也值得一看。 当出现病理性输入时，某些程序最终可能会花费大量时间来分配和初始化兆字节的内存。  -m值低可以使它们更早放弃并且不浪费CPU时间**。[<font color=blue>译者注：程序是如何通过-m，起限制作用？</font>]

## 8. Check OS configuration

有几个os级别的因素可能会影响fuzzing速度。

1. 高系统负载。 尽可能使用闲置的计算机。 杀死所有不必要的CPU消耗（空闲浏览器窗口，媒体播放器，复杂的屏幕保护程序等）。

2. 网络文件系统，用于模糊器的输入/输出，或由模糊的二进制文件访问以读取配置文件（特别注意主目录-许多程序在其中搜索点文件）。

3. 按需CPU缩放。  Linux“按需”调控器会按特定的时间表执行分析，并且众所周知，它会低估由afl-fuzz（或任何其他fuzzer）产生的短暂进程的需求。 在Linux上，可以通过以下方法解决此问题：

   ```shell
       cd /sys/devices/system/cpu
       echo performance | tee cpu*/cpufreq/scaling_governor
   ```

4. 在其他系统上，CPU扩展的影响将有所不同。 在进行模糊测试时，请使用特定于操作系统的工具来确定所有内核是否都在全速运行。

5. 透明的大页面。 在内核中启用透明大页面（THP）时，某些分配器（例如jemalloc）可能会产生大量的模糊测试损失。 您可以通过以下方式禁用此功能：

   ```shell
   echo never > /sys/kernel/mm/transparent_hugepage/enabled
   ```

6. 次优的调度策略。 每个目标的重要性各不相同，但是在Linux上，您可能需要确保设置了以下选项：

   ```shell
       echo 1 >/proc/sys/kernel/sched_child_runs_first
       echo 1 >/proc/sys/kernel/sched_autogroup_enabled
   ```

   为Fuzzer进程设置不同的调度策略（例如SCHED_RR）通常也可以加快速度，但是需要格外小心。

## 9. If all other options fail, use -d

对于真正很慢的程序，如果您真的无法使用大输入文件来逃脱，或者仅想在早期获得快速而肮脏的结果，则始终可以使用-d模式。

该模式使afl-fuzz跳过所有确定性的模糊步骤，从而使输出的整洁度降低很多，并最终使测试的深度降低一些，但是它将为您提供其他模糊工具带来的更熟悉的体验。[<font color=blue>译者注：？？？</font>]