原文地址：:point_right: [AFL -- Notes for using ASAN with afl-fuzz](https://github.com/google/AFL/blob/master/docs/notes_for_asan.txt)

这个文件讨论了在ASAN下fuzzing的一些注意事项，并提出了一些备选方案。一般使用手册请参阅自述文件。

[<font color=blue>译者注释：总体是介绍ASAN的使用注意。不仅仅适用于模糊测试：使用32位编译or运行前估算下内存使用</font>]

1. 内容提要

   64位系统上的ASAN要求大量内存，而这种方式导致的崩溃，很难与程序自身导致的崩溃区别开来。

   **因此，使用ASAN进行fuzzing只推荐在四种情况下使用:**

   * 在32位系统上，我们总是可以强制实施合理的内存限制（-m 800左右是一个很好的起点）
   * 在64位系统上，只有当你可以做以下之一:
     * 在32位模式下编译二进制文件(gcc -m32)
     * 精确测量程序需要的内存：http://jwilk.net/software/recidivm
     * 使用cgroup限制内存的使用

   要使用ASAN进行编译，请在调用“make clean all”之前设置AFL_USE_ASAN = 1。  afl-gcc / afl-clang包装器会选择并添加适当的标志。请注意，ASAN与-static不兼容，因此请注意这一点。

   > (You can also use AFL_USE_MSAN=1 to enable MSAN instead.)

   **还可以选择使用非ASAN二进制文件生成语料库，然后将其提供给ASAN测试的程序集以检查错误**。 这样速度更快，并且可以为您提供可比的结果。 您还可以尝试使用libdislocator（请参见父目录中的libdislocator / README.dislocator）作为一种轻量级且无麻烦（但不太彻底）的替代方法。

2. 详细介绍

   ASAN为bookkeeping目的分配了很大的虚拟地址空间区域。其中大多数都从未真正访问过，因此OS无需为该进程分配任何实际的内存页，并且ASAN抢占的VM本质上是“免费的”-但映射计入标准的OS会有所强制限制（RLIMIT_AS， 又名ulimit -v）。

   在我们的最后，afl-fuzz试图保护您免受进程偏离轨道并开始消耗所有可用内存的徒劳，企图解析格式错误的输入文件。 这种情况经常出乎意料地发生，因此对几乎任何一个模糊测试者来说，强制执行这样的限制都是很重要的：替代方法是让内核OOM处理程序介入并开始杀死随机进程以释放资源。不用说，这不是一个很好的前景。

   不幸的是，un * x系统无法提供一种可移植的方式来限制实际分配给进程的页面数量，从而区分该进程和ASAN进行的无害“抢地”。 原则上，有三种标准的方法来限制堆的大小：

   * RLIMIT_AS机制（ulimit -v）限制了虚拟空间的大小，但是如前所述，它并不关注该进程实际使用的页面数，因此在这里无济于事。
   * RLIMIT_DATA机制（ulimit -d）看起来很合适，但它仅适用于请求堆空间的传统sbrk（）/ brk（）方法； 现代的分配器，包括glibc中的分配器，通常改为依赖mmap（），并完全规避此限制。
   * 最后，RLIMIT_RSS限制（ulimit -m）听起来像我们所需要的，但是在Linux上不起作用-主要是因为没人愿意实现它。

   也有cgroup，但是它们是特定于Linux的，即使在Linux系统上也不是通用的，并且它们需要root权限才能设置。 我有点犹豫是否要让afl-fuzz要求具有root权限。 也就是说，**如果您使用的是Linux，并且想使用cgroups，请查看experimental / asan_cgroups /中附带的贡献脚本**。

   **在无法使用cgroup的设置中，我们没有一种可移植的好方法来避免将ASAN分配计入限制**。 在32位系统上，或者对于以32位模式（-m32）编译的二进制文件，这没什么大不了的：取决于编译器，ASAN大约需要600-800 MB左右-因此，您要做的就是 指定比-m高一点的-m。

   在64位系统上，情况更加模糊，因为ASAN分配完全不合时宜-旧版本约为17.5 TB，最新版本接近20 TB。 因此，除非您以外科手术的精确度拨出限制，否则您将无法获得针对OOM错误的保护。

   在我的系统上，稍早版本的gcc的ASAN占用的内存量约为17,825,850 MB。 对于最新的clang，它是20,971,600MB。但是并不能保证这些数字是稳定的，如果您仅仅“几次”演出就弄错了它们，那么您将处于危险之中。

   要获得准确的数字，可以使用Jakub Wilk（http://jwilk.net/software/recidivm）开发的recidivm工具。 如果没有这种情况，则在对64位二进制文件进行模糊处理时，*不*建议*使用ASAN，除非您确信它们很健壮并强制执行合理的内存限制（在这种情况下，可以在调用afl-fuzz时指定“ -m none”）  。

   使用recidivm或不加限制地运行，还有其他两种不错的选择：使用非ASAN二进制文件构建测试用例集，然后在更可控的环境中使用ASAN，Valgrind或其他重型工具检查它们； 或使用-m32（32位模式）编译目标程序（如果系统支持）。

3. QEMU模式的交互

   ASAN，MSAN和其他清理程序似乎与QEMU用户仿真不兼容，因此请不要尝试将它们与-Q选项一起使用；  QEMU似乎不喜欢这些工具使用的影子VM技巧，并且可能只会分配您的所有物理内存，然后崩溃。

4. ASAN and OOM crashes

   默认情况下，ASAN将内存分配失败视为致命错误，立即导致程序崩溃。 由于这与常规的POSIX语义背道而驰（并且在其他行为正常的程序中引起了安全问题的出现），因此我们尝试通过在ASAN_OPTIONS中指定allocator_may_return_null = 1来禁用此功能。

   不幸的是，据报道，在标准分配器仅返回NULL的情况下，此设置仍会导致ASAN触发幻像崩溃。 如果这干扰了您的繁琐工作，则您可能想抄送自己：这个错误： https://bugs.llvm.org/show_bug.cgi?id=22026

5. 一些人对使用UBSAN进行模糊测试表示了兴趣。 官方不支持此功能，因为许多UBSAN安装并没有提供一致的方法来在故障情况下中止（）或以独特的退出代码终止。

   也就是说，可以对该库的某些版本进行二进制修补，以解决此问题，而较新的版本则支持显式的编译时标志-请参见此邮件列表线程以获取提示：  https://groups.google.com/forum/#!topic/afl-users/GyeSBJt4M38