[toc]

原文地址：:point_right: [AFL -- README.md](https://github.com/google/AFL)

这里翻译源码中的README代替官网中的document。两者内容上几乎一样，但源码中的README是彩色的，好看。

<br>

# american fuzzy lop

最初由Michal Zalewski开发lcamtuf@google.com。

如果你没有时间阅读这个文档，可以参看[快速开始](./快速开始.md)

<br>

## 1. 引导的模糊测试的挑战

模糊检测是识别实际软件中安全问题的最强大，最成熟的策略之一。 它负责迄今为止在安全性至关重要的软件中发现的绝大多数远程代码执行和特权提升错误。

不幸的是，模糊测试还比较浅。 盲目的，随机的变异使得极不可能到达测试代码中的某些代码路径，从而使某些漏洞牢不可破。

已经进行了许多尝试来解决这个问题。 由塔维斯·奥曼迪（Tavis Ormandy）率先提出的早期方法之一是语料库蒸馏。 该方法依靠覆盖信号从大量高质量的候选文件语料库中选择有趣种子的子集，然后通过传统方式对其进行模糊处理。 该方法工作得非常好，但是需要这样的语料库是随时可用的。 另外，块覆盖率测量仅提供了对程序状态的非常简单的理解，并且对于指导长距离的模糊测试工作没有多大用处。

其他更复杂的研究集中在诸如程序流分析（动态符号执行），符号执行或静态分析之类的技术上。 所有这些方法在实验环境中都是非常有前途的，但是在实际使用中往往会遇到可靠性和性能方面的问题，并且目前还不能提供“dumb”模糊测试技术的可行替代方案。

[<font color=blue>译者注：AFL并没有结合关于动态符号执行等技术</font>]

<br>

## 2. afl-fuzz 采用的模糊测试方法

American Fuzzy Lop是一种蛮力模糊测试器，结合了极其简单但坚如磐石的instrumentation-guided genetic algorithm。 **它使用修改后的边缘覆盖形式**，毫不费力地拾取程序控制流中局部的细微变化。

[<font color=blue>译者注：修改在哪里，覆盖率如何分类，有什么优缺点，有哪些工具，在哪里使用</font>]

简化一下，整个算法可以总结为：

1. 将用户提供的初始测试用例加载到队列中
2. 从队列中获取下一个输入文件
3. 尝试将测试用例缩减到不改变程序测量行为的最小大小
4. 使用平衡和充分研究各种传统模糊策略反复变异文件
5. 如果生成的任何突变导致检测记录的新状态转换，则将突变的输出添加为队列中的新条目
6. Go to 2

发现的测试用例也会定期被剔除，以消除那些已经被更新的、覆盖率更高的发现所淘汰的测试用例;并经历其他一些instrumentation-driven的工作最小化步骤。

作为fuzzing过程的一个附带结果，该工具创建了一个小型的、自包含的**有趣测试用例的语料库**。**这对于其他劳动密集型或资源密集型的测试机制非常有用**，例如，对浏览器、办公应用程序、图形套件或闭源工具进行压力测试。

fuzzer经过彻底的测试，提供开箱即用的性能，远优于盲目的fuzzing或仅覆盖工具。

<br>

## 3. Instrumenting programs for use with AFL

当源代码可用时， instrumentation可以通过配套工具被注入，该工具可以在第三方代码的任何标准构建过程中替代gcc或clang。

 instrumentation对性能的影响很小。 结合afl-fuzz实现的其他优化，大多数程序可以比传统工具更快甚至更快地被模糊化。

重新编译目标程序的正确方法可能会因构建过程的具体情况而异，但几乎通用的方法是：

```shell
$ CC=/path/to/afl/afl-gcc ./configure
$ make clean all
```

对于C++程序，可能这样设置，`CXX=/path/to/afl/afl-g++`

可以使用相同的方式使用clang包装器（afl-clang和afl-clang ++）。 **clang用户还可以选择使用更高性能的检测模式，如llvm_mode/README.llvm中所述**。

在测试库时，您需要找到或编写一个简单的程序，该程序将从stdin或文件中读取数据并将其传递给测试的库。  在这种情况下，必须将此可执行文件链接到检测库的静态版本，或者确保在运行时加载正确的.so文件（通常通过设置LD_LIBRARY_PATH），这一点很重要。 最简单的选择是静态构建，通常可以通过以下方式进行：

```shell
$ CC=/path/to/afl/afl-gcc ./configure --disable-shared
```

在调用“ make”时设置`AFL_HARDEN` = 1将使CC包装器自动启用代码强化选项，**从而更容易检测简单的内存错误**。   [Libdislocator](libdislocator.md)是AFL附带的帮助程序库（请参阅**libdislocator/README.dislocator**）也可以帮助发现堆损坏问题。

PS.建议使用ASAN用户查看**notes_for_asan.txt**文件，了解重要的注意事项。

[<font color=blue>译者注：AFL是在内存检测上(可以)做了哪些工作，llvm_mode是个不错的选择</font>]

<br>

## 4. 无源码的二进制程序的Instrumenting

当源代码不可用时，模糊器将提供实验支持，以快速，即时地instrumentation黑匣子二进制文件。 这是通过以鲜为人知的“用户空间仿真”模式运行的QEMU版本完成的。

QEMU是一个独立于AFL的项目，但您可以通过以下方式方便地构建该特性。

```shell
$ cd qemu_mode
$ ./build_qemu_support.sh
```

有关其他说明和注意事项，请参阅qemu_mode/README.qemu。

该模式比编译时工具慢大约2-5倍，不利于并行化，并且可能还有其他一些quirks。

[<font color=blue>译者注：对于二进制程序进行测试，并不是黑盒测试，也非常有意思。这里先不关注二进制的模糊测试。</font>]

<br>

## 5. 选择初始测试用例

为了正确运行，模糊器需要一个或多个启动文件，其中包含目标应用程序通常期望的输入数据的良好示例。 有两个基本规则：

保持文件较小。 尽管并非绝对必要，但低于1 kB是理想的。 有关大小为何重要的讨论，请参见[perf_tips.txt](./perf_tips.md)。

**仅在功能彼此不同的情况下，才使用多个测试用例。 使用五十张不同的度假照片来模糊图像库是没有意义的**。

您可以在此工具随附的testcases/子目录中找到许多启动文件的好例子。

PS: 如果有大量数据可用于筛选，则可能要使用afl-cmin实用程序来识别功能不同的文件的子集，这些文件在目标二进制文件中具有不同的代码路径。

<br>

## 6. Fuzzing binaries

模糊处理过程本身是由afl-fuzz实用程序执行的。 该程序需要一个带有初始测试用例的只读目录，一个单独的位置来存储其发现结果以及要测试的二进制文件的路径。

对于直接从stdin接受输入的目标二进制文件，通常的语法是： 

```shell
$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]
```

对于从文件中获取输入的程序，请使用“ @@”在目标的命令行中标记应放置输入文件名的位置。 模糊测试器将代替您：

```shell
$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@
```

您也可以使用-f选项将变异数据写入特定文件。 如果程序需要特定的文件扩展名，则此功能很有用。

Non-instrumented binaries可以在QEMU模式下（在命令行中添加-Q）或在传统的盲目模糊器模式下（指定-n）进行模糊处理。

您可以使用-t和-m覆盖已执行进程的默认超时和内存限制； 可能需要涉及这些设置的目标的罕见示例包括编译器和视频解码器。

perf_tips.txt中讨论了优化模糊测试性能的技巧。

请注意，afl-fuzz首先执行一系列确定性的模糊测试步骤，这可能需要花费几天的时间，但往往会产生简洁的测试用例。 如果您想立即获得快速且肮脏的结果（类似于zzuf和其他传统的模糊测试器），请在命令行中添加-d选项。

<br>

## 7. 解释输出

请参阅[status_screen.txt](./status_screen.md)文件以获取有关如何解释显示的统计信息和监视进程运行状况的信息。 请确保查阅此文件，尤其是如果任何UI元素以红色突出显示。

模糊处理将继续，直到您按Ctrl-C为止。 至少，您希望允许模糊器完成一个队列周期，这可能需要几个小时到一周左右的时间。

程序在输出目录中创建了三个子目录，并实时对其进行了更新：

1. queue/：每个独特执行路径的测试用例，以及用户提供的所有起始文件。 这是第2节中提到的综合语料库。在将该语料库用于其他目的之前，可以使用afl-cmin工具将其缩小为较小的大小。 该工具将查找较小的文件子集，以提供等效的边缘覆盖率。
2. crashes/：导致被测试程序收到致命信号的独特测试用例（例如，SIGSEGV，SIGILL，SIGABRT）。 这些条目按接收到的信号分组。
3. hangs/：导致测试程序超时的unique test cases （相同的hang，只保留一份case）。 将某物归类为挂起之前的默认时间限制为1秒和-t参数的值中的较大者。 可以通过设置AFL_HANG_TMOUT来微调该值，但这很少需要。

如果关联的执行路径涉及以前记录的故障中未发现的任何状态转换，则崩溃和挂起被视为“唯一”。 如果可以通过多种方式到达同一个错误，那么在此过程的早期阶段就会出现一些inflation，但这应该很快就会逐渐消失。

崩溃和挂起的文件名与父级非故障队列条目相关联。 这应该有助于调试。

当您无法重现由afl-fuzz发现的崩溃时，最可能的原因是您没有设置与该工具相同的内存限制。 尝试：

```shell
$ LIMIT_MB=50
$ ( ulimit -Sv $[LIMIT_MB << 10]; /path/to/tested_binary ... )
```

更改LIMIT_MB以匹配传递给afl-fuzz的-m参数。在OpenBSD上，也将-Sv更改为-Sd。

**任何现有的输出目录也可以用于恢复已中止的作业**。 尝试：

```shell
任何现有的输出目录也可以用于恢复已中止的作业。 尝试：
```

如果安装了**gnuplot**，则还可以使用afl-plot为任何活动的模糊测试任务生成一些漂亮的图形。 有关其外观的示例，请参见http://lcamtuf.coredump.cx/afl/plot/。

<br>

## 8. 并行的模糊测试

每一个afl-fuzz实例都大约占据一个核心。这意味着在多核系统上，为了充分利用硬件，并行化是必要的。有关如何在多核或多台联网机器上模糊一个共同目标的技巧，请参阅[parallel_fuzzing.txt](./parallel_fuzzing.md)。

**并行模糊模式也提供了一种简单的方法，可以将AFL与其他模糊器，符号执行或动态符号执行引擎等接口**。 再次，请参见parallel_fuzzing.txt的最后一节以获取提示。

[<font color=blue>译者注：并行测试值得关注</font>]

<br>

## 9. 模糊测试器的字典

**默认情况下，afl-fuzz突变引擎针对紧凑的数据格式进行了优化-例如图像，多媒体，压缩数据，正则表达式语法或shell脚本**。 它不太适合具有特别冗长和冗余的语言的语言-特别是包括HTML，SQL或JavaScript。

**为了避免构建语法识别工具的麻烦，afl-fuzz提供了一种方法，可以使用与目标数据类型关联的可选语言关键字，魔术头或其他特殊标记的字典来为模糊处理提供种子**。 随时随地的基本语法： http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html

要使用此功能，您首先需要以字典/README.dictionaries中讨论的两种格式之一创建字典。 然后通过命令行中的-x选项将模糊器指向它。

（该子目录中已经提供了几个常用词典。）

无法提供对底层语法的更多结构化描述，但是模糊器可能会仅基于工具反馈来找出其中的一些。 实际上，这实际上是可行的，例如：	

http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html

PS。 **即使没有给出明确的字典，afl-fuzz也会通过在确定性字节翻转期间密切观察工具来尝试提取输入语料库中现有的语法标记**。 这适用于某些类型的解析器和语法，但不及-x模式。

<br>

## 10. 崩溃分类

基于覆盖率的崩溃分组通常会产生一个小的数据集，可以手动或使用非常简单的GDB或Valgrind脚本对其进行快速分类。 每次崩溃都可追溯到队列中其父级非崩溃测试用例，从而更容易诊断故障。

话虽如此，重要的是要认识到，如果不进行大量调试和代码分析工作，就很难快速评估某些模糊崩溃的可利用性。 为了协助完成此任务，**afl-fuzz支持一种非常独特的“崩溃探索”模式，该模式启用了-C标志**。

在这种模式下，模糊器将一个或多个崩溃的测试用例作为输入，并使用其反馈驱动的模糊策略来非常快速地枚举程序中可以到达的所有代码路径，同时将其保持在崩溃状态。

不导致崩溃的突变将被拒绝； 任何不影响执行路径的更改也是如此。

输出是一小批文件，可以对其进行快速检查，以查看攻击者对错误地址的控制程度，或者是否有可能越过初始越界读取-并查看其背后的内容。  

哦，还有一件事：为了使测试用例最小化，请尝试一下afl-tmin。 该工具可以通过非常简单的方式进行操作：

```shell
$ ./afl-tmin -i test_case -o minimized_result -- /path/to/program [...]
```

该工具适用于崩溃和非崩溃的测试用例。 在崩溃模式下，它将很乐意接受已检测和未检测的二进制文件。 在非崩溃模式下，最小化程序依靠标准的AFL工具来使文件更简单，而无需更改执行路径。

最小化器以与afl-fuzz兼容的方式接受-m，-t，-f和@@语法。

AFL的另一个最新功能是afl-analyze工具。 它需要一个输入文件，尝试顺序翻转字节，并观察被测试程序的行为。 然后，根据哪些部分看起来很关键，哪些不是关键部分，对输入进行颜色编码。 尽管不是bulletproof，但它通常可以提供对复杂文件格式的快速洞察。 有关其操作的更多信息，请参见technical_details.txt的末尾。

<br>

## 11. Going beyond crashes

模糊测试技术也可以用来发现no-crashing和implementation error。一些有趣的bugs已经被发现，通过修改目标程序调用abort()：

* 当给定相同的fuzzer生成的输入时，两个bignum库产生不同的输出
* 当要求在一行中多次解码相同的输入图像时，图像库产生不同的输出
* 当迭代序列化和反序列化模糊器提供的数据时，序列化/反序列化库无法产生稳定的输出
* 当要求压缩然后解压缩特定的Blob时，压缩库会产生与输入文件不一致的输出

实施这些或类似的sanity checks通常只需要很少的时间。 如果您是特定软件包的维护者，则可以使用#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION（也与libfuzzer共享的标志）或#ifdef __AFL_COMPILER（此代码仅用于AFL）将此代码作为条件代码。

<br>

## 12. Common-sense risks

请记住，与许多其他计算密集型任务类似，模糊测试可能会给您的硬件和操作系统造成压力。 特别是：

* 您的CPU将运行热，需要充分的冷却。 在大多数情况下，如果冷却不足或无法正常工作，则将自动限制CPU速度。 就是说，尤其是当在不太适合的硬件（笔记本电脑，智能手机等）上进行模糊测试时，炸毁并不是完全不可能的。

* 目标程序最终可能会失控地抢夺GB的内存或用垃圾文件填充磁盘空间。  AFL试图强制执行基本的内存限制，但不能防止每一个可能的事故。 最重要的是，您不应该为那些数据丢失风险不可接受的系统而感到困惑。
* 模糊测试涉及对文件系统的数十亿次读取和写入。 在现代系统上，这通常会被大量缓存，从而导致相当适度的“物理” I / O-但有许多因素可能会改变此等式。 监视潜在的故障是您的责任； 如果I / O非常繁重，则许多HDD和SSD的使用寿命可能会缩短。

在Linux上监视磁盘I / O的一种好方法是'iostat'命令：

```shell
 $ iostat -d 3 -x -k [...optional disk ID...]
```

<br>

## 13. 已知限制和需要改进的地方

Here are some of the most important caveats for AFL:

* AFL通过检查由于信号（SIGSEGV，SIGABRT等）而导致的第一个生成进程死亡来检测故障。 安装这些信号的自定义处理程序的程序可能需要注释掉相关代码。 同样，除非您手动添加一些代码来捕获被模糊目标所产生的子处理中的错误，否则它们可能会逃避检测。
* 与任何其他蛮力工具一样，如果使用加密，校验和，加密签名或压缩来完全包装要测试的实际数据格式，则模糊器的覆盖范围有限。
  要解决此问题，您可以注释掉相关检查（请参阅experimental / libpng_no_checksum /以获取灵感）； 如果无法做到这一点，您也可以编写一个后处理程序，如experimental / post_library /中所述。

* 不幸的是，与ASAN和64位二进制文件之间存在一些取舍。 这不是由于afl-fuzz的任何特定故障引起的； 有关提示，请参见notes_for_asan.txt。

* 对于需要UI交互才能起作用的模糊网络服务，后台守护程序或交互式应用程序，没有直接支持。 您可能需要进行简单的代码更改，以使它们以更传统的方式运行。  Preeny也可能提供一个相对简单的选项-参见：https://github.com/zardus/preeny

  还可在以下网址找到一些有关修改基于网络的服务的有用提示：https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop

* AFL不会输出人类可读的覆盖率数据。 如果要监视覆盖范围，请使用Michael Rash的afl-cov：https://github.com/mrash/afl-cov
* Occasionally, sentient machines rise against their creators. If this happens to you, please consult http://lcamtuf.coredump.cx/prep/. (>_<)

除此之外，请参阅INSTALL以获取特定于平台的技巧。

<br>

## 特别感谢

Many of the improvements to afl-fuzz wouldn't be possible without feedback, bug reports, or patches from:

```shell
 Jann Horn                             Hanno Boeck
  Felix Groebert                        Jakub Wilk
  Richard W. M. Jones                   Alexander Cherepanov
  Tom Ritter                            Hovik Manucharyan
  Sebastian Roschke                     Eberhard Mattes
  Padraig Brady                         Ben Laurie
  @dronesec                             Luca Barbato
  Tobias Ospelt                         Thomas Jarosch
  Martin Carpenter                      Mudge Zatko
  Joe Zbiciak                           Ryan Govostes
  Michael Rash                          William Robinet
  Jonathan Gray                         Filipe Cabecinhas
  Nico Weber                            Jodie Cunningham
  Andrew Griffiths                      Parker Thompson
  Jonathan Neuschfer                    Tyler Nighswander
  Ben Nagy                              Samir Aguiar
  Aidan Thornton                        Aleksandar Nikolich
  Sam Hakim                             Laszlo Szekeres
  David A. Wheeler                      Turo Lamminen
  Andreas Stieger                       Richard Godbee
  Louis Dassy                           teor2345
  Alex Moneger                          Dmitry Vyukov
  Keegan McAllister                     Kostya Serebryany
  Richo Healey                          Martijn Bogaard
  rc0r                                  Jonathan Foote
  Christian Holler                      Dominique Pelle
  Jacek Wielemborek                     Leo Barnes
  Jeremy Barnes                         Jeff Trull
  Guillaume Endignoux                   ilovezfs
  Daniel Godas-Lopez                    Franjo Ivancic
  Austin Seipp                          Daniel Komaromy
  Daniel Binderman                      Jonathan Metzman
  Vegard Nossum                         Jan Kneschke
  Kurt Roeckx                           Marcel Bohme
  Van-Thuan Pham                        Abhik Roychoudhury
  Joshua J. Drake                       Toby Hutton
  Rene Freingruber                      Sergey Davidoff
  Sami Liedes                           Craig Young
  Andrzej Jackowski                     Daniel Hodson
```

Thank you!

<br>

## Contact

Questions? Concerns? Bug reports? Please use GitHub.

There is also a mailing list for the project; to join, send a mail to [afl-users+subscribe@googlegroups.com](mailto:afl-users+subscribe@googlegroups.com). Or, if you prefer to browse archives first, try: https://groups.google.com/group/afl-users.